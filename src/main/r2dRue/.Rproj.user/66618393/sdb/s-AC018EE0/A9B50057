{
    "contents" : "\neditr2dRfile = function(conf='') {\n###############################################\n# NAME: r2dRueWiz\n# PURPOSE:\n#     Read an 2dRue configuration file and perform actions acordely \n#     Can calculate the monitoring, the assessment, both or none, acordely with the input.\n# INPUTS:\n#       conf: config file. If none is provided, it will be create through interactive questions to the user \n# OUTPUTS:\n#       r2dRue wiz is a procedure that can produced all the output involved in r2dRue analisys.\n#\t\tIt will be created a log file named as the config file but with its extension turned to .log\t\n\tinput=function(tag,default=''){\n\t\tif (default!='') tag=paste(tag,' [',default,']',sep='')\n\t\trepeat {\n\t\t\taux=readline(paste(tag,' ?: ',sep=''))\n\t\t\tif (aux!='') {\n\t\t\t\treturn(aux);break\n\t\t\t} \n\t\t\tif ((aux=='') & (default!='')) {\n\t\t\t\treturn(default);break\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\n\t\n\tyear=function(x) {as.integer(format(x,'%Y'))}\n\tmonth=function(x) {as.integer(format(x,'%m'))}\n\t\n\tcanReadRgf = function(x) {\t\t\n\t\tif (!is.na(file.info(x)$isdir) & (file.info(x)$isdir==FALSE)) {\t\t\t\n\t\t\taux=rgf.read(x)\n\t\t\tif (!is.na(file.info(aux[1])$isdir) & (file.info(aux[1])$isdir==FALSE)){\n\t\t\t\timg=readGDAL(aux[1],silent=TRUE)\t\t\t\n\t\t\t\tif (class(img)=='SpatialGridDataFrame')  {return(TRUE)}\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn(FALSE)\n\t}\n\t\n\t############################## main\n\tresponse=list(comment='',viRgf='',rainRgf='',petRgf='',mHidro='',acum='',pOut='',sYear='',sMonth='',yIni='',yEnd='',driver='',flag='')\n\t\t\n\ttext=\"##########################################\\n############# r2dRue Wizard ##############\\n#                                        #\\n\\n\"\n\t\n\t#options(show.error.messages=FALSE)\n\ttry({\n\t\tconaux=as.data.frame(readConfigFile(conf),stringsAsFactors=FALSE)\n\t\tresponse[names(conaux)]=conaux\n\t})\n\tif (response$pOut=='') response$pOut=getwd()\n\tif (response$driver=='') response$driver='RST'\n\tif (response$flag=='') response$flag=-999\n\tif (conf=='') conf=paste('rue',format(Sys.time(), \"%d%b\"),'.conf',sep='')\n\t\n\tcat(text)\n\ttry({\n\t\tresponse$comment=input('Description of this run',response$comment)\t\t\n\t\trepeat {\n\t\t\taux=input('Output directory',response$pOut)\n\t\t\tsub('[/\\\\]$','',aux)\n\t\t\tif (!is.na(file.info(aux)$isdir) & (file.info(aux)$isdir!=FALSE)) {response$pOut=aux; break}\n\t\t\telse print('the directory does not exist...create first')\n\t\t}\t\n\t\trepeat {\n\t\t\taux=input('Vegetation Index raster group',response$viRgf)\n\t\t\tif (canReadRgf(aux)) {response$viRgf=aux; break}\n\t\t\telse print('cant read this raster group...')\n\t\t}\n\t\trepeat {\n\t\t\taux=input('Precipitation raster group',response$rainRgf)\t\t\t\n\t\t\tif (canReadRgf(aux)) {response$rainRgf=aux; break}\n\t\t\telse print('cant read this raster group...')\n\t\t}\n\t\trepeat {\n\t\t\taux=input('PET raster group',response$petRgf)\n\t\t\tif (canReadRgf(aux)) {response$petRgf=aux; break}\n\t\t\telse print('cant read this raster group...')\n\t\t}\n\t\trepeat {\n\t\t\taux=input('Start moment (yyyy/mm) of these raster groups',paste(response$sYear,response$sMonth,sep='/'))\n\t\t\ter=try({aux=as.Date(paste(aux,'01',sep='/'))})\t\t\n\t\t\tif (class(er)!='try-error') {sDate=aux; break}\n\t\t\telse print('not a date')\n\t\t}\n\t\trepeat {\n\t\t\taux=input('Start month of hydrological year [1-12]',response$mHidro)\n\t\t\ter=try({iaux=as.integer(aux)})\t\t\n\t\t\tif (iaux %in% 1:12) {response$mHidro=iaux; break}\n\t\t\telse print('its simple... [1-12]')\n\t\t}\n\t})\n\t\n\t#options(show.error.messages=TRUE)\n\tsvi=rgf.read(response$viRgf)\n\tsrain=rgf.read(response$rainRgf)\n\tspet=rgf.read(response$petRgf)\t\n\t\n\t#calculate dates of the elements in the serie \n\tsLength=length(svi)\n\tsIniDate=sDate\n\tsDates=seq(sIniDate,length.out=sLength,by='month')\n\tsEndDate=sDates[sLength]\n\t\n\tsIniYear=year(sIniDate)\n\tsEndYear=year(sEndDate)\n\t\n\tsHYears=sFailHYears=0\n\tfor (i in sIniYear:sEndYear) {\n\t\taux1=as.Date(paste(i,response$mHidro,1,sep='/'))\n\t\taux2=seq(aux1,length.out=12,by='month')[12]\n\t\tif ((aux1 %in% sDates) & (aux2 %in% sDates)) sHYears=c(sHYears,i)  \n\t\telse sFailHYears=c(sFailHYears,i)\n\t}\t\n\tsHYears=sHYears[-1]\n\tsFailHYears=sFailHYears[-1]\n\t\t\n\t#show info\n\tcat(sprintf('\\nOriginal data: %d images, from %s to %s',sLength,format(sIniDate,'%b/%Y'),format(sEndDate,'%b/%Y')))\n\tcat(sprintf('\\n             : %d Hydrological years, %s - %s starting in %s',length(sHYears),sHYears[1],sHYears[length(sHYears)],month.name[response$mHidro]))\n\tcat(sprintf('\\n             : %d Incomplete Hydrological years: %s\\n',length(sFailHYears),paste(sFailHYears,collapse=', ')))\n\t\t\n\trepeat {\n\t\taux=input('Number of cumulative months for preceding rain',response$acum)\n\t\ter=try({iaux=as.integer(aux)})\t\t\n\t\tif (iaux %in% 1:30) {response$acum=iaux; break}\n\t\telse print('its simple... a integer great than 0')\n\t}\n\t\n\tpreDate=sort(seq(as.Date(paste(sHYears[1],response$mHidro,1,sep='/')),length.out=response$acum+1,by='-1 months')[-1])\n\t\t\n\tif (!(preDate[1] %in% sDates)) sHYears=sHYears[-1]\n\t\n\trepeat {\n\t\taux=input(sprintf('Start year of this run [%d-%d]',sHYears[1],sHYears[length(sHYears)]),response$yIni)\n\t\ter=try({iaux=as.integer(aux)})\t\t\n\t\tif (iaux %in% sHYears) {response$yIni=iaux; break}\n\t\telse sprintf('[%d-%d]',sHYears[1],sHYears[length(sHYears)])\n\t}\n\trepeat {\n\t\taux=input(sprintf('End year of this run [%d-%d]',sHYears[1],sHYears[length(sHYears)]),response$yEnd)\n\t\ter=try({iaux=as.integer(aux)})\t\t\n\t\tif (iaux %in% sHYears) {response$yEnd=iaux; break}\n\t\telse sprintf('[%d-%d]',sHYears[1],sHYears[length(sHYears)])\n\t}\n\trepeat {\t\t\n\t\taux=input('GIS format for output images',response$driver)\t\t\t\t\n\t\tif (isSupportedGDALFormat(aux)) {response$driver=aux; break}\n\t\telse print('a valid write GDAL driver')\n\t}\n\trepeat {\n\t\taux=input('Missing value for output images',response$flag)\n\t\ter=try({iaux=as.integer(aux)})\t\t\n\t\tif (is.integer(iaux)) {response$flag=iaux; break}\n\t\telse print('integer')\n\t}\n\t\n\tresponse$sYear=year(sIniDate)\n\tresponse$sMonth=month(sIniDate)\n\t\n\tfileName=input('File name for this config file',conf)\t\n\twrite.table(t(as.data.frame(response)),fileName,sep='=',quote=FALSE,col.names=FALSE)\t\n}\n\nr2dRplot=function(o,type='rain',scope='run',var='vi',pixel=1,col=c('blue','green4','salmon','gray')){\n##############################################\n# NAME: ruePlot\n# PURPOSE:\n#     Read an 2dRue configuration file and perform actions acordely \n#     Caln calculate the monitoring, the assessment, both or none, acordely with the input.\n# INPUTS:\n\tif (o$summarize) {\n\tswitch(type,\t\t\n\t\t'vimax'= {\t\t\n\t\t\tnf <- layout(matrix(c(1,1,2,3,3,4), 3, 2))\t\t\t\n\t\t\ta=readGDAL(o$viMax,silent=TRUE)\n\t\t\timage(a)\n\t\t\ttitle(main='vi maximum')\n\t\t\tplot(density(a$band1,na.rm=TRUE),main='',xlab='vi')\n\t\t\ta=readGDAL(o$viMaxWhen)\n\t\t\timage(a)\n\t\t\ttitle(main='when vi maximum')\n\t\t\thist(o$sDates[a$band1],xlab='months',breaks='months',format='%b%y',las=3,freq=T)\t\t\t\n\t\t},\n\t\t'box'= {\n\t\t\tif (var=='vi') boxplot(o$RESvi$box,names=format(o$rDates,'%b%y'),las=3,main='spatially lumped vegetation index',ylab='vegetation index')\n\t\t\tif (var=='rain') boxplot(o$RESrain$box,names=format(o$rDates,'%b%y'),las=3,main='spatially lumped precipitation',ylab='rain (mm)')\t\t\n\t\t},\n\t\t'density'= {\t\t\n\t\t\tif (var=='vi') plot(o$RESvi$deny~o$RESvi$denx,type='l',col=c(1:12))\n\t\t\tif (var=='rain') plot(o$RESrain$deny~o$RESrain$denx,type='l',col=c(1:12))\n\t\t},\n\t\t'rain'= {\n\t\t\tbarplot(o$RESrain$summ[6,],col=4,names=format(o$rDates,'%b%y'),las=3,main='Precipitation',ylab='rain (mm)')\n\t\t\tbarplot(o$RESrain$summ[4,],add=T,col=3)\n\t\t\tbarplot((o$RESrain$summ[6,]==0)*-10,add=T,col='red')\t\t\n\t\t},\n\t\t'assessment1'= {\n\t\t\ta=readGDAL(o$rueEx,silent=TRUE)\n\t\t\ta$rueObsEx=a$band1\n\t\t\ta$rueObsMe=readGDAL(o$rueMe,silent=TRUE)$band1\n\t\t\ta$aiObsEx=readGDAL(o$aiEx,silent=TRUE)$band1\n\t\t\ta$aiObsMe=readGDAL(o$aiMe,silent=TRUE)$band1\n\t\t\tnf <- layout(matrix(c(1,2), 1, 2))\n\t\t\tlayout.show(nf)\t\t\t\t\t\t\n\t\t\tplot(a$rueObsEx~a$aiObsEx,main='rue vs ai - Extremo',xlab='aiObsEx',ylab='rueObsEx')\n\t\t\tplot(a$rueObsMe~a$aiObsMe,main='rue vs ai - Medio',xlab='aiObsMe',ylab='rueObsMe')\n\t\t\t\n\t\t},\n\t\t'assessment2'= {\n\t\t\ta=readGDAL(o$rueEx,silent=TRUE)\n\t\t\ta$rueObsEx=a$band1\n\t\t\ta$rueObsMe=readGDAL(o$rueMe,silent=TRUE)$band1\n\t\t\ta$aiObsEx=readGDAL(o$aiEx,silent=TRUE)$band1\n\t\t\ta$aiObsMe=readGDAL(o$aiMe,silent=TRUE)$band1\n\t\t\tnf <- layout(matrix(c(1,2), 1, 2))\t\t\t\n\t\t\tplot(spplot(a,zcol=c('rueObsEx','rueObsMe','aiObsEx','aiObsMe')))\n\t\t},\n\t\t'monitoring'= {\n\t\t\ta=readGDAL(o$f1,silent=TRUE)\n\t\t\ta$rueObsEx=a$f1band1\n\t\t\ta$rueObsMe=readGDAL(o$f2,silent=TRUE)$band1\n\t\t\ta$aiObsEx=readGDAL(o$f3,silent=TRUE)$band1\n\t\t\ta$f4=readGDAL(o$f4,silent=TRUE)$band1\n\t\t\tnf <- layout(matrix(c(1,2), 1, 2))\n\t\t\tlayout.show(nf)\n\t\t\tplot(spplot(a,zcol=c('rueObsEx','rueObsMe','aiObsEx','aiObsMe')))\n\t\t},\n\t\t'pixel'={\t\t\t\t\n\t\t\tpos=pixel*o$sLength*4\n\t\t\tin1=file(o$STKsvi,'rb')\n\t\t\tin2=file(o$STKsrain,'rb')\n\t\t\tseek(in1,pos)\n\t\t\tseek(in2,pos)\n\t\t\tbvi  =readBin(in1,numeric(),o$sLength,4)\n\t\t\tbrain=readBin(in2,numeric(),o$sLength,4)\t\t\n\t\t\tmaxbrain=max(brain)\t\t\t\n\t\t\tposmaxvi=which(bvi==max(bvi))\n\t\t\t#preposmaxvi=o$sDate[which(bvi==max(bvi))-o$acum]\n\t\t\tplot(o$sDate,bvi,type='l',ylim=c(0,1),col=col[2],ylab='vegetation index & rain (scaled)',xaxt='n',main=paste('VI & Rain for pixel ',pixel))\n\t\t\taxis.Date(1, at=seq(o$sIniDate,o$sEndDate,by='year'),las=3,cex.axis=1)\n\t\t\t# TODO: arreglar cuando - acum es negativo...\n\t\t\tif (length(posmaxvi)!=0) rect(o$sDates[posmaxvi-o$acum],0,o$sDates[posmaxvi],1,density=10,col=col[4],border=col[3])\t\t\t\n\t\t\tlines(o$sDate,brain/maxbrain,type='h',col=col[1])\n\t\t\tabline(v=o$sDates[posmaxvi],col=col[3])\n\t\t\tlines(o$sDate,bvi,type='l',col=col[2],lwd=2)\n\t\t\tclose(in1)\n\t\t\tclose(in2)\n\t\t})\n\t} else (stop('summarize not done... ejecute summarize() function first'))\n}\n\nshowInfo=function (o) {\n###############################################\n# NAME: \n# PURPOSE:\n# INPUTS:\n# OUTPUTS:\n###############################################\t\n\t#print info\n\taux='\\n'\n\taux=c(aux,'\\n',sprintf('################### r2dRue RUN: %s',o$comment))\n\taux=c(aux,'\\n',sprintf('Original data: %d images, from %s to %s',o$sLength,format(o$sIniDate,'%b/%Y'),format(o$sEndDate,'%b/%Y')))\n\taux=c(aux,'\\n',sprintf('Analysis data: %d images, from %s to %s, %d Hydrological years starting in %s',o$rLength,format(o$rIniDate,'%b/%Y'),format(o$rEndDate,'%b/%Y'),o$rYears,month.name[o$mHidro]))\n\taux=c(aux,'\\n',sprintf('               %d cumulative precipitation months, %d preceding images from  %s to %s',o$acum, length(o$ppet),format(o$rPreDates[1],'%b/%Y'),format(o$rPreDates[length(o$ppet)],'%b/%Y') ))\n\taux=c(aux,'\\n\\n',sprintf('---------- Raster Group Info'))\n\taux=c(aux,'\\n',sprintf('viRgf     : %s',attr(o$vi,'path')))\n\taux=c(aux,'\\n',sprintf('            %s ...',paste(head(attr(o$vi,'files'),10),collapse=' ')))\n\taux=c(aux,'\\n',sprintf('rainRgf   : %s',attr(o$rain,'path')))\n\taux=c(aux,'\\n',sprintf('            %s ...',paste(head(attr(o$rain,'files'),10),collapse=' ')))\n\taux=c(aux,'\\n',sprintf('petRgf    : %s',attr(o$pet,'path')))\n\taux=c(aux,'\\n',sprintf('            %s ...',paste(head(attr(o$pet,'files'),10),collapse=' ')))\n\taux=c(aux,'\\n',sprintf('preRainRgf: %s',attr(o$prain,'path')))\n\taux=c(aux,'\\n',sprintf('            %s ...',paste(head(attr(o$prain,'files'),10),collapse=' ')))\n\taux=c(aux,'\\n',sprintf('prePetRgf : %s',attr(o$ppet,'path')))\n\taux=c(aux,'\\n',sprintf('            %s ...',paste(head(attr(o$ppet,'files'),10),collapse=' ')))\n\taux=c(aux,'\\n\\n',sprintf('---------- Spatial Info'))\n\taux=c(aux,'\\n',sprintf('cols: %d  rows: %d  res: %f  proj: %s',o$gdal[1],o$gdal[2],o$gdal[6],attr(o$gdal,'projection')))\n\taux=c(aux,'\\n')\n\tcat(aux)\n\tif (o$assessment){\n\t\tcat(c('\\n',paste('---------- Assessment results at ',attr(o$assessment,'date')),'\\n'))\t\t\n\t\tprint(attr(o$assessment,'summary'))\n\t}else{cat(c('\\n',sprintf('---------- assessment results not updated')))}\n\tif (o$monitoring){\n\t\tcat(c('\\n',paste('---------- Monitoring results at ',attr(o$monitoring,'date')),'\\n'))\n\t\tprint(attr(o$monitoring,'summary'))\n\t}else{cat(c('\\n',sprintf('---------- Monitoring results not updated')))}\n\tcat('\\n')\n\t\n}\n\n###############################################\n# NAME: \n# PURPOSE: Lee un fo\n# INPUTS:\n# OUTPUTS:\nreadConfigFile=function (conf) {\t\n\tco=list(\n\t\t\tpOut='',mHidro='',acum='',viRgf='',rainRgf='',sYear='',sMonth='',\n\t\t\tyIni='',yEnd='',driver='',flag='',petRgf='',\n\t\t\tcomment='',acction=''\n\t)\n\tobligatorios=names(co)[1:12]\t\n\tf=readIniFile(conf)\n\tco[names(f)]=f\t\n\tif (any(co[obligatorios] == '')) stop(sprintf('Faltan parametros obligatorios en %s, check the conf file',conf))\t\n\tco\n}\n\n###############################################\n# NAME: createRunConfig\n# PURPOSE:\n#     crea una lista con la informacion necesaria para una ejecucion de 2dRue\n# INPUTS:\n#     conf: lista de configuracion basica (sin campos calculados) \n# OUTPUTS:\nreadr2dRfile=function (conf){\n\t#campos forzados a enteros\n\tenteros=c('mHidro','acum','sYear','sMonth','yIni','yEnd')\n\t#definicion inicial\n\to=list(\n\t\t#from config file\n\t\tcomment='',pOut='',mHidro='',acum='',viRgf='',rainRgf='',sYear='',sMonth='',\n\t\tyIni='',yEnd='',driver='',flag='',acction='',petRgf='',\n\t\t#calculated\t\t\n\t\tvi='',rain='',pet='',ppet='',prain='',rLength='',rIniDate='',rEndDate='',rDates='',rPreDates='',\n\t\tsvi='',srain='',spet='',sIniDate='',sEndDate='',sDates='',sLength='',\t\t\n\t\t#calculated spaciales\n\t\tgdal='',\n\t\t#calculates extern\n\t\tassessment=FALSE,rueMed='',rueEx='',aiMed='',aiEx='',\n\t\tmonitoring=FALSE,f1='',f2='',f3='',f4='',f5='',f6='',f7='',f8='',f9='',\n\t\tsummarize=FALSE,viMax='',whenviMax=''\n\t)\n\t\n\t#read fields from file\n\tco=readConfigFile(conf)\n\to[names(co)]=co #copy fields from config file\t\n\to[enteros]=as.integer(co[enteros]) #pasar a enteros\t\n\t\t\n\t#read rgf files\n\to$svi=rgf.read(o$viRgf)\n\to$srain=rgf.read(o$rainRgf)\n\to$spet=rgf.read(o$petRgf)\n\tstopifnot(length(o$spet)==length(o$svi))\n\t\n\t#calculate dates of the elements in the serie \n\to$sLength=length(o$svi)\n\to$sIniDate=as.Date(paste(o$sYear,o$sMonth,1,sep='/'))\n\to$sDates=seq(o$sIniDate,length.out=o$sLength,by='month')\n\to$sEndDate=o$sDates[o$sLength]\n\t\t\n\to$rYears=o$yEnd-o$yIni+1\n\to$rLength=o$rYears*12\t\n\to$rIniDate=as.Date(paste(o$yIni,o$mHidro,1,sep='/'))\n\to$rDates=seq(o$rIniDate,length.out=o$rLength,by='month')\n\to$rEndDate=o$rDates[o$rLength]\n\t\t\n\to$rPreDates=sort(seq(o$rIniDate,length.out=o$acum+1,by='-1 month')[-1])\n\n\tif (!all(o$rDates %in% o$sDates)) {\n\t\tprint(o$rDates)\n\t\tprint(o$sDates)\n\t\tstop('check start and initial dates')\n\t}\n\tif (!all(o$rPreDates %in% o$sDates)) stop('check start and initial dates')\n\t\n\t#spatial atributes\n\to$gdal=GDALinfo(o$svi[1],silent=TRUE)\t\n\tif (!isSupportedGDALFormat(o$driver)) stop('not supported GDAL driver')\n\tif (!is.finite(as.numeric(o$flag))) stop('not a valid missing value flag ')\n\t\n\t#calculate vi,rain,pet,ppet and prain series\n\to$vi=o$svi[o$sDates %in% o$rDates]\n\to$rain=o$srain[o$sDates %in% o$rDates]\n\to$pet=o$spet[o$sDates %in% o$rDates]\n\to$ppet=o$spet[o$sDates %in% o$rPreDates]\n\to$prain=o$srain[o$sDates %in% o$rPreDates]\n\t\n\t#calculate atributes\n\tattr(o$vi,'path')=dirname(o$vi[1])\n\tattr(o$rain,'path')=dirname(o$rain[1])\n\tattr(o$pet,'path')=dirname(o$pet[1])\n\tattr(o$ppet,'path')=dirname(o$ppet[1])\n\tattr(o$prain,'path')=dirname(o$prain[1])\n\tattr(o$vi,'files')=basename(o$vi)\n\tattr(o$rain,'files')=basename(o$rain)\n\tattr(o$pet,'files')=basename(o$pet)\n\tattr(o$ppet,'files')=basename(o$ppet)\n\tattr(o$prain,'files')=basename(o$prain)\t\n\t\t\n\t#show\n\tshowInfo(o)\n\t#return\t\n\to\t\n}\n\n\nsummarize=function(o){\n\t#parameters name in parent frame (to do a 'by reference')\n\toriginalo=deparse(substitute(o))\n\to$summarize=FALSE\n\t#outNames\n\toutNames=c('svi.stk','srain.stk','vimax','viMaxWhen')\n\toutNames=paste(o$pOut,'/',outNames,'.',o$driver,sep='')\n\t#reasterStack\n\trasterStack(o$svi,outNames[1],interleave='BIP')\n\trasterStack(o$srain,outNames[2],interleave='BIP')\n\to$STKsvi=outNames[1]\n\to$STKsrain=outNames[2]\n\t#viMax & viMaxWhen\n\trgf.summary(o$vi,outNames[3],fun='MAX')\n\taux=rgf.when(o$vi,outNames[3])\n\twriteGDAL(aux,outNames[4])\n\to$viMax=outNames[3]\n\to$viMaxWhen=outNames[4]\n\t#summary vi and rain series\n\to$RESvi=rgf.summarize(o$vi)\n\to$RESrain=rgf.summarize(o$rain)\t\n\to$summarize=TRUE\n\tassign(originalo,o,envir=parent.frame())\n}\n\n###############################################\n# NAME: assessment\n# PURPOSE:\n# INPUTS:\n# OUTPUTS:\nassessment = function(o) {\n\t#parameters name in parent frame (to do a 'by reference')\n\toriginalo=deparse(substitute(o))\n\t#set assessment flag to FALSE\t\n\to$rueEx=o$rueMed=o$aiEx=o$aiMed=''\t\t\n\to$assessment=FALSE\n\tassign(originalo,o,envir=parent.frame())\n\t#def files\n\toutNames=c('rueObsMe','rueObsEx','aiObsMe','aiObsEx')\n\toutNames=paste(o$pOut,'/',outNames,'.',o$driver,sep='')\n\t#try to make Indices\t\n\ter=try({\t\t\n\t\t\trueMe=rueObsMe(o$rain,o$vi)\n\t\t\twriteGDAL(rueMe,outNames[1],drivername=o$driver,mvFlag=o$flag)\n\t\t\tiaMe=aiObsMe(o$rain,o$pet)\n\t\t\twriteGDAL(iaMe,outNames[3],drivername=o$driver,mvFlag=o$flag)\n\t\t\trueEx=rueObsEx(o$rain,o$vi,o$prain,nMonths=o$acum)\n\t\t\twriteGDAL(rueEx,outNames[2],drivername=o$driver,mvFlag=o$flag)\t\t\t\t\n\t\t\tiaEx=aiObsEx(o$rain,o$vi,o$pet,o$prain,o$ppet,nMonths=o$acum)\t\n\t\t\twriteGDAL(iaEx,outNames[4],drivername=o$driver,mvFlag=o$flag)\n\t})\n\t#update o\n\tif (!class(er)=='try-error'){\n\t\to$rueEx=outNames[1];\n\t\to$rueMed=outNames[2];\n\t\to$aiEx=outNames[3];\n\t\to$aiMed=outNames[4];\t\n\t\to$assessment=TRUE \n\t\tattr(o$assessment,'date')=format(Sys.time(),'%d %b %Y %H:%M:%S')\n\t\taux=matrix(0, nrow = 4, ncol=7, dimnames = list(c('rueObsMe','rueObsEx','aiObsMe','aiObsEx'),c(\"Min\",\"1st Qu\",\"Median\",\"Mean\",\"3rd Qu\",\"Max\",\"NA's\")))\n\t\tfor (i in 1:4) {\t\n\t\t\taux1=summary(readGDAL(outNames[i],silent=TRUE)$band1)\n\t\t\tif (length(aux1)==6) aux1=c(aux1,0)\n\t\t\taux[i,]=aux1\n\t\t}\n\t\tattr(o$assessment,'summary')=aux\n\t\tassign(originalo,o,envir=parent.frame())\n\t}\n}\n\n\n\n###############################################\n# NAME: monitoring\n# PURPOSE:\n# INPUTS:\n# OUTPUTS:\nmonitoring = function(o) {\t\n\t#parameters name in parent frame (to do a 'by reference')\n\toriginalo=deparse(substitute(o))\n\t#set monitoring flag to FALSE\t\n\to$f1=o$f2=o$f3=o$f4=o$f5=o$f6=o$f7=o$f8=o$f9=''\t\t\t\n\to$monitoring=FALSE\n\tassign(originalo,o,envir=parent.frame())\n\t#def files\n\toutNames=c('index','effect_time','effect_arid','veg_response','ta_single','tv_single','av_single')\n\toutNames=paste(o$pOut,'/',outNames,'.',o$driver,sep='')\n\tannualVis=paste(o$pOut,'/viMed',o$yIni:o$yEnd,'.',o$driver,sep='')\n\tannualIaMed=paste(o$pOut,'/aiMed',o$yIni:o$yEnd,'.',o$driver,sep='')\n\tannualTimes=paste(o$pOut,'/time',o$yIni:o$yEnd,'.',o$driver,sep='')\n\t#try to make Indices\t\n\ter=try({\t\n\t\tprint('---------- Make annuals Vegetation Index Means')\t\t\n\t\trgf.summary(o$vi,annualVis,step=12,fun='MEAN',drivername=o$driver,mvFlag=o$flag)\t\t\n\t\t#make aiObsMed by hidrologic years\t\n\t\tprint('---------- Make annuals Aridity Index')\t\t\t\t\n\t\tn=o$rYears\n\t\tfor (i in 0:(n-1)) {\n\t\t\tetp12=o$pet[(1:12)+i*12]\n\t\t\train12=o$rain[(1:12)+i*12]\n\t\t\taiMe=aiObsMe(rain12,etp12,silent=T)\n\t\t\twriteGDAL(aiMe,annualIaMed[i+1],drivername=o$driver,mvFlag=o$flag)\n\t\t}\t\t\n\t\tprint('---------- Make annuals time series')\n\t\t#make annual time files\t\t\n\t\taux=readGDAL(annualVis[1],silent=T)\t\n\t\tfor (i in 0:(n-1)) {\n\t\t\taux$band1=o$yIni+i\n\t\t\twriteGDAL(aux,annualTimes[i+1],drivername=o$driver,mvFlag=o$flag)\n\t\t}\n\t\t#make step by step regresion\n\t\tprint('---------- Make Step by Step regresion')\n\t\tregStepRaster(annualVis,annualTimes,annualIaMed\t,outNames,drivername=o$driver,mvFlag=o$flag)\n\t})\n\t#update o\n\tif (!class(er)=='try-error'){\n\t\to$f1=outNames[1]\n\t\to$f2=outNames[2]\n\t\to$f3=outNames[3]\n\t\to$f4=outNames[4]\t\n\t\to$f5=outNames[5]\n\t\to$f6=outNames[6]\n\t\to$f7=outNames[7]\t\t\n\t\to$monitoring=TRUE\n\t\tattr(o$monitoring,'date')=format(Sys.time(),'%d %b %Y %H:%M:%S')\n\t\taux=matrix(0, nrow = 7, ncol=7, dimnames = list(c('index','effect_time','effect_arid','veg_response','ta_single','tv_single','av_single'),c(\"Min\",\"1st Qu\",\"Median\",\"Mean\",\"3rd Qu\",\"Max\",\"NA's\")))\n\t\tfor (i in 1:7) {\n\t\t\taux1=summary(readGDAL(outNames[i],silent=TRUE)$band1)\n\t\t\tif (length(aux1)==6) aux1=c(aux1,0)\n\t\t\taux[i,]=aux1\n\t\t}\n\t\tattr(o$monitoring,'summary')=aux\t\t\n\t\tassign(originalo,o,envir=parent.frame())\n\t}\n}\n\n\n###############################################\n# NAME: rueObsMe\n# PURPOSE:\n#     Reads n ndvi files and n rainfall grid files\n#     Then Calculate the RueObsMe grid.\n# INPUTS:\n#       rainFl: File names list of rainfall grid \n#       viFl: File names list of vegetation index grid \n#       silent: logical Flag; if TRUE, comments outputs are supressed\n# OUTPUTS:\n#       Return RueObsMe as a SpatialGridDataFrame/SpatialPixelDataframe class. \nrueObsMe = function(rainFl, viFl, silent=FALSE) {\n\t\n\tif (length(rainFl)!=length(viFl)) stop('rainFl & viFl must have the same length')\n\tif (length(rainFl)%%12!=0) stop('rainFl must be multiply of 12')\t\n\tif (length(rainFl)<12) stop('rainFl length must be greater or equal than 12')\n\t\n\t#Extraer el numero de elementos del array \n\tn=length(rainFl) #num de meses en la serie\n\tnah=floor(n/12)    #num de years hidrologicos\n\t\n\tif (!silent) {\n\t\tprint(paste('Procesing rueObsMe for', nah, 'years ---'))\n\t\tpb =txtProgressBar(min=0,max=n,char='*',width=20,style=3)\n\t}\n\t\n\tRueMed=0 \n\t\n\t# Para cada year hidrologico\n\tfor (i in 0:(nah-1)) {\t  \n\t\tSumRain=0\n\t\tSumNdvi=0\n\t\t#Para cada mes del year hidrologico\n\t\tfor (j in 1:12){\n\t\t\tSumRain = SumRain+readGDAL(rainFl[i*12+j],silent=TRUE)$band1\n\t\t\tSumNdvi = SumNdvi+readGDAL(viFl[i*12+j],silent=TRUE)$band1\n\t\t\tif (!silent) setTxtProgressBar(pb, i*12+j)\n\t\t}\n\t\tSumNdvi=SumNdvi/12\n\t\tif (sum(SumRain == 0, na.rm=TRUE) > 0) SumRain=SumRain+(SumRain == 0) # cambio los pixels a 0mm de lluvia acumulada por 1mm\n\t\tRueMed=RueMed+(SumNdvi/SumRain)\n\t}\n\tRueMed=RueMed/nah\n\taux=readGDAL(rainFl[1],silent=TRUE)\n\taux$band1=RueMed\n\tif (!silent) close(pb)\n\taux\n}\n\n\n##########################################################################\n#\n# NAME: GIaMed\n#\n# PURPOSE:\n#     Reads n ndvi files and n rainfall files\n#     Then Calculate the RUEMAX(ndvi_1..ndvi_n, rainfall_1..rainfall_n, m, errorfile) functiones with m#index\n#\n# INPUTS:\n#       FilesArr: array [0..n#1] of String with name of IDRISI RST input files\n#\n#                 FilesArr[0]     # The no values mask filename\n#                 FilesArr[1,12]  # The 12 precipitationes filename\n#                 FilesArr[13,24] # The 12 evapotransipirationes files\n#\n# OUTPUTS:\n#       Return Rue Maximun map,\n\naiObsMe=function (rainFl, petFl, FAO=FALSE, silent=FALSE){\n\t\n\tif (length(rainFl)!=length(petFl)) stop('rainFl & petFl must have the same length')\n\tif (length(rainFl)%%12!=0) stop('rainFl must be multiply of 12')\t\n\tif (length(rainFl)<12) stop('rainFl length must be greater or equal than 12')\n\t\n\t#Extraer el numero de elementos del array \n\tn=length(rainFl) #num de meses en la serie\n\tnah=floor(n/12) #num de years hidrologicos\n\t\n\tif (!silent){\n\t\tprint(paste('Processing aiObsMe for', nah, 'years ---'))\n\t\tpb =txtProgressBar(min=0,max=n,char='*',width=20,style=3)\n\t}\n\tIaMed=0\n\t\n\t# Para cada year hidrologico\n\tfor (i in 0:(nah-1)){\n\t\tSumRain=0\n\t\tSumPet=0\n\t\t#Para cada mes del year hidrologico\n\t\tfor (j in 1:12){\n\t\t\tSumRain = SumRain+readGDAL(rainFl[i*12+j],silent=TRUE)$band1\n\t\t\tSumPet  = SumPet +readGDAL(petFl[i*12+j],silent=TRUE)$band1\n\t\t\tif (!silent) setTxtProgressBar(pb, i*12+j)\n\t\t}\n\t\t\n\t\tif (FAO) {\n\t\t\tif (sum(SumPet  == 0, na.rm=TRUE) > 0) SumPet =SumPet +(SumPet  == 0) # cambio los pixels a 0mm de Pet acumulada por 1mm\n\t\t\tIaMed=IaMed+(SumRain/SumPet)\n\t\t} else {\n\t\t\tif (sum(SumRain == 0, na.rm=TRUE) > 0) SumRain=SumRain+(SumRain == 0) # cambio los pixels a 0mm de lluvia acumulada por 1mm\n\t\t\tIaMed=IaMed+(SumPet/SumRain)\n\t\t}\n\t}\n\t\n\tIaMed=IaMed/nah\n\taux=readGDAL(rainFl[1],silent=TRUE)\n\taux$band1=IaMed\n\tif (!silent) close(pb)\n\taux\n}\n\n\n############################333\n# NAME: GRueMax\n#\n# PURPOSE:\n#     Reads m ndvi files, m rainfall files, and a NMA map (numero de meses de acumulacion)\n#     Then Calculate the RUEMAX\n#\n# INPUTS:\n#       rainFl: File names list of rainfall grids \n#       viFl: File names list of vegetation index grids\n#       preRainFl:  File names list of previous rainfall grids \n#       Nma: cte de acumulacion\n#       silent: logical Flag; if TRUE, comments outputs are supressed\n# OUTPUTS:\n#       Return Rue Maximun map, and the Rue Max Month map\n# TODO: Fallo con acum=1 .. ver = en aiObsEx\n\nrueObsEx = function (rainFl, viFl, preRainFl, nMonths=6, silent=FALSE){\n\t\n\tif (length(rainFl)!=length(viFl)) stop('rainFl & viFl must have the same length')\n\tif (length(rainFl)%%12!=0) stop('rainFl must be multiply of 12')\t\n\tif (length(rainFl)<12) stop('rainFl length must be greater or equal than 12')\n\tif (is.character(nMonths)) {\n\t\tfaux=readGDAL(nMonths,silent=TRUE)\n\t\tm=faux$band1\n\t\tnMonths=max(m)\n\t} else {\n\t\tfaux=readGDAL(rainFl[1],silent=TRUE)\n\t\tfaux$band1=nMonths\n\t\tm=faux$band1\n\t}\n\t\n\tif (length(preRainFl)<nMonths) stop(paste('preRain length mus be at least ',nMonths,'elements'))\n\t\n\t#Extraer el numero de elementos del array \n\tn=length(rainFl) #num de meses en la serie\n\tnah=floor(n/12) #num de years hidrologicos\n\t\n\tRainFifo=0 \n\tNdviMax=0\n\tNdviMaxMon=0\n\tAux=0\n\tRueMax=0    \n\t\n\t# Calcula NdviMax y NdviMaxMonth\n\tif (!silent) {\n\t\tprint(paste('Processing rueObsEx for', nah, 'years ---'))\n\t\tprint('Processing vegetation index files')\n\t\tpb =txtProgressBar(min=1,max=n,char='*',width=20,style=3)\n\t} \n\tfor (i in 1:n) {\n\t\tAux=readGDAL(viFl[i],silent=TRUE)$band1\n\t\tNdviMax=pmax(Aux,NdviMax)\n\t\tMsk=(Aux == NdviMax)\n\t\tNdviMaxMon=NdviMaxMon*(!Msk)+i*Msk #Mes indicado de 0 a n-1\n\t\tif (!silent) setTxtProgressBar(pb, i)\n\t}\n\t \n\tif (!silent) {\n\t\tclose(pb)\n\t\tprint('Processing rain files')\n\t\tpb =txtProgressBar(min=1,max=nMonths,char='*',width=20,style=3)\n\t}\n\t#relleno fifo con los nMonths primeros meses    \n\tfor (i in 1:nMonths) {\n\t\tRainFifo=cbind(RainFifo,readGDAL(preRainFl[i],silent=TRUE)$band1)\n\t\tsetTxtProgressBar(pb, i)\n\t}\n\tRainFifo=RainFifo[,-1] #eliminamos primera columna de 0s\n\t\n\tif (!silent) {\n\t\tclose(pb)\t\t\t\n\t\tpb =txtProgressBar(min=1,max=n,char='*',width=20,style=3)\n\t}\n#browser()\n\t#for each month in the serie\n\tfor (i in 1:n) {\n\t\t#Calculate the mask of NdviMaxMon for month i\n\t\t#pixeles donde el ndvi maximo se obtuvo en el mes numero i\n\t\tMskMonth=(NdviMaxMon == i)       \n\t\t# Para cada valor de los nMonths posibles\n\t\tSumRain=0\n\t\tfor (j in 1:nMonths) {\n\t\t\t#Calcular imagenes de lluvia acumulada en j meses\n\t\t\tSumRain=SumRain+RainFifo[,nMonths+1-j] #lo acumulamos\n\t\t\t#Calcula mascara de pixeles con m=j\n\t\t\tMsknMonths=(m == j)#\n\t\t\tif (sum(MsknMonths)>0) {\n\t\t\t\t#Calcular RueMax\n\t\t\t\tif (sum(SumRain == 0, na.rm=TRUE) > 0) SumRain=SumRain+(SumRain == 0) # cambio los pixels a 0mm de lluvia acumulada por 1mm\n\t\t\t\tRueMax=RueMax*(!MskMonth)+(NdviMax/SumRain)*MsknMonths*MskMonth #overlay RueMax\n\t\t\t}\n\t\t}\n\t\t#Desplazar Fifo e insertar mes\n\t\tRainFifo=cbind(RainFifo[,-1],readGDAL(rainFl[i],silent=TRUE)$band1)\n\t\tif (!silent) setTxtProgressBar(pb, i)\n\t}\n\t\n\tfaux$band1=RueMax\n\tif (!silent) close(pb)\n\tfaux\n}\n\n# NAME:\n#       GIAMax\n#\n# PURPOSE:\n#     Reads n ndvi files and n rainfall files\n#     Then Calculate the RUEMAX(ndvi_1..ndvi_n, rainfall_1..rainfall_n, m, errorfile) functiones with m-index\n#\n# INPUTS:\n#       FilesArr: array [0..n-1] of String with name of IDRISI RST input files\n#\n#                 FilesArr[0]     - The no values mask filename\n#                 FilesArr[1,12]  - The 12 precipitationes filename\n#                 FilesArr[13,24] - The 12 evapotransipirationes files\n#\n# OUTPUTS:\n#       Return Rue Maximun map,\n\naiObsEx = function (rainFl, viFl, petFl, preRainFl, prePetFl, FAO=FALSE, nMonths=6, silent=FALSE) {\n\tif (length(rainFl)!=length(viFl)) stop('rainFl & viFl must have the same length')\n\tif (length(rainFl)%%12!=0) stop('rainFl must be multiply of 12')\t\n\tif (length(rainFl)<12) stop('rainFl length must be greater or equal than 12')\n\tif (is.character(nMonths)) {\n\t\tfaux=readGDAL(nMonths,silent=TRUE)\n\t\tm=faux$band1\n\t\tnMonths=max(m)\n\t} else {\n\t\tfaux=readGDAL(rainFl[1],silent=TRUE)\n\t\tfaux$band1=nMonths\n\t\tm=faux$band1\n\t}\n\t\n\tif (length(preRainFl)<nMonths) stop(paste('preRain length mus be at least ',nMonths,'elements'))\n\t\n\t#Extraer el numero de elementos del array \n\tn=length(rainFl) #num de meses en la serie\n\tnah=floor(n/12) #num de years hidrologicos\n\t\n\tRainFifo=0 \n\tPetFifo=0  \n\tviMax=0\n\tviMaxMon=0\n\tAux=0\n\tIaMax=0\n\t\n\t# Calcula NdviMax y NdviMaxMonth\n\tif (!silent) {\n\t\tprint(paste('Processing aiObsEx for', nah, 'years ---'))\n\t\tprint('Processing vegetation index files')\n\t\tpb =txtProgressBar(min=1,max=n,char='*',width=20,style=3)\n\t}\n\tfor (i in 1:n) {\n\t\tAux=readGDAL(viFl[i],silent=TRUE)$band1\n\t\tviMax=pmax(Aux,viMax)\n\t\tMsk=(Aux == viMax)\n\t\tviMaxMon=viMaxMon*(!Msk)+i*Msk #Mes indicado de 0 a n-1\n\t\tif (!silent) setTxtProgressBar(pb, i)\n\t}\n\tif (!silent) {\n\t\tclose(pb)\n\t\tprint('Processing data')\n\t}\n\tpb =txtProgressBar(min=1,max=nMonths,char='*',width=20,style=3)\n\t#relleno fifo con los nMonths primeros meses    \n\tfor (i in 1:nMonths) {\n\t\tRainFifo=cbind(RainFifo,readGDAL(preRainFl[i],silent=TRUE)$band1)\n\t\tPetFifo=cbind(PetFifo,readGDAL(prePetFl[i],silent=TRUE)$band1)\n\t\tif (!silent) setTxtProgressBar(pb, i)\n\t}\n\tRainFifo=RainFifo[,-1] #eliminamos primera columna de 0s\n\tPetFifo=PetFifo[,-1] #eliminamos primera columna de 0s\n\t\n\tif (!silent) {\n\t\tclose(pb)\t\t\n\t\tpb =txtProgressBar(min=1,max=n,char='*',width=20,style=3)\n\t}\n\t#for each month in the serie\n\tfor (i in 1:n) {\n\t\t#Calculate the mask of viMaxMon for month i\n\t\t#pixeles donde el vi maximo se obtuvo en el mes numero i\n\t\tMskMonth=(viMaxMon == i)       \n\t\t# Para cada valor de nMonths de los 12 posibles\n\t\tSumRain=0\n\t\tSumPet=0\n\t\tfor (j in 1:nMonths) {\n\t\t\t#Calcular imagenes de lluvia acumulada en j meses\n\t\t\tSumRain=SumRain+RainFifo[,nMonths+1-j] #lo acumulamos\n\t\t\tSumPet=SumPet+PetFifo[,nMonths+1-j] #lo acumulamos\n\t\t\t#Calcula mascara de pixeles con nMonths=j\n\t\t\tMsknMonths=(m == j)#\n\t\t\tif (sum(MsknMonths)>0) {\n\t\t\t\t#Calcular IaMax\n\t\t\t\tif (FAO) {\n\t\t\t\t\tif (sum(SumPet  == 0, na.rm=TRUE) > 0) SumPet =SumPet +(SumPet  == 0) # cambio los pixels a 0mm de Pet acumulada por 1mm\n\t\t\t\t\tIaMax=IaMax*(!MskMonth)+(SumRain/SumPet)*MsknMonths*MskMonth #overlay RueMax\n\t\t\t\t} else {\n\t\t\t\t\tif (sum(SumRain == 0, na.rm=TRUE) > 0) SumRain=SumRain+(SumRain == 0) # cambio los pixels a 0mm de lluvia acumulada por 1mm\n\t\t\t\t\tIaMax=IaMax*(!MskMonth)+(SumPet/SumRain)*MsknMonths*MskMonth #overlay RueMax\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#Desplazar Fifo e insertar mes\n\t\tRainFifo=cbind(RainFifo[,-1],readGDAL(rainFl[i],silent=TRUE)$band1)\n\t\tPetFifo=cbind(PetFifo[,-1],readGDAL(petFl[i],silent=TRUE)$band1)\n\t\tif (!silent) setTxtProgressBar(pb, i)\n\t}\n\tfaux$band1=IaMax\n\tif (!silent) close(pb)\n\tfaux\n}\n\n###############################################\n# NAME: \n# PURPOSE:\n# INPUTS:\n# OUTPUTS:\n###############################################\nrasterStack=function(inFl,outFN,asc=FALSE,zip=FALSE,dec=3,interleave='BIP',silent=FALSE){\n\t\n\t#comprueba condiciones de error\n\tif (length(inFl)<2) stop('inFl must be at least of length 2')\n\tif (nchar(outFN)==0) stop('Empty output file name')\n\tif (interleave %in% c('BIL','BIP','BSQ') == FALSE) stop('Invalid interleave. Valid are BIL, BIP, BSQ')\n\tif ((interleave %in% c('BIL','BSQ')) & (!missing(asc) || !missing(zip) || !missing(dec))) { \n\t\tasc=FALSE\n\t\tzip=FALSE\n\t\tdec=3\n\t\tprint('asc,zip,dec options are ignored in interleave mode BIL or BSQ')\n\t}\n\t\n\t#num de imagenes en la lista \n\tnimg=length(inFl)\n\t\n\t#num de filas y columnas de la imagen\n\trows=GDALinfo(inFl[1])[1]\n\tcols=GDALinfo(inFl[1])[2]\n\t\n\t#calculo size del buffer de lectura para que lea bloques de 100MB\n\tlinesToRead=ceiling(100000000/(cols*nimg*8))\n\t\n\t#num de bloques de size linesToRead en la imagen\n\tnblocks=ceiling(rows/linesToRead)\n\t\n\t#inicio progressbar\n\tif (!silent) pb=txtProgressBar(min=0,max=nblocks*nimg,char='*',width=20,style=3)\n\t\n\t#abrir fichero de salida en modo write + (texto, texto comprimido o binario)\n\tif (asc) { \n\t\tif (zip) {\n\t\t\tft=gzfile(outFN,'wt')\n\t\t} else ft=file(outFN,'wt')\n\t} else ft=file(outFN,'wb')\n\t\n\tif (interleave=='BSQ') {\n\t\tstop('sorry, not implemented yet...')\n\t}  else {\n\t\t\n\t\t#leemos lineToRead (ej. 200 lineas) de cada imagen \n\t\t#anexamos cada bloque leido a la columna de un dataframe \n\t\t#escribimos en disco el datafame con la opcion de anexar \n\t\t#el proceso se repite para los nblocks necesarios\n\t\tfor (j in 0:(nblocks-1)){\n\t\t\t#iniciamos dataframe de salida\n\t\t\toutdf=0\n\t\t\tfor (i in 1:nimg){\n\t\t\t\taux=GDAL.open(inFl[i],TRUE)  \n\t\t\t\t#offsets\n\t\t\t\toffsetIni=j*linesToRead+1\n\t\t\t\toffsetFin=(j+1)*linesToRead\n\t\t\t\t#no rebasar fin de archivo\n\t\t\t\tif (offsetFin>rows) offsetFin=rows\n\t\t\t\t#lee bloque de la imagen SIN cargarla completamente en memoria \n\t\t\t\tStrip=aux[offsetIni:offsetFin,]\n\t\t\t\t#cerrar conexion\n\t\t\t\tGDAL.close(aux)\n\t\t\t\t#anexar como columna al dataframe de salida    \n\t\t\t\toutdf=cbind(outdf,Strip$band1)  \n\t\t\t\t#actualizo progressbar\n\t\t\t\tif (!silent) setTxtProgressBar(pb, i+nimg*j)\n\t\t\t} #for\n\t\t\t#convertir outdf a vector, y darle la forma adecuada para guardarlo en disco\n\t\t\toutdf=outdf[,-1]\n\t\t\tif (asc) {\n\t\t\t\toutdf=round(outdf,dec)\n\t\t\t\twrite.table(outdf,ft,row.names=FALSE,col.names=FALSE,sep=',')\n\t\t\t} else {\n\t\t\t\tif (interleave=='BIL') writeBin(as.vector(as.matrix(outdf)),ft,size=4)\n\t\t\t\tif (interleave=='BIP' & !asc) writeBin(as.vector(t(as.matrix(outdf))),ft,size=4)\n\t\t\t}\n\t\t} #for\n\t\tclose(ft)\n\t\tclose(pb)\n\t}\n}\n\n###############################################\n# NAME: \n# PURPOSE:\n# INPUTS:regStepRaster(vi,y,ia,fl,drivername='RST',mvFlag=-1)\n# OUTPUTS:\n###############################################\nregStepRaster=function(ndviFl,timeFl,aridFl,outFl,silent=FALSE,...){\n\t#comprueba condiciones de error\n\tif (length(outFl)!=7) stop('outFl may be a list of seven filenames')\n\tif (2*length(ndviFl)!=(length(timeFl)+length(aridFl))) stop('ndviFl, tempFl and aridFl, should have equal length')\n\t\n\t#Stack by pixel the filelists\n\ttmpFn1=tempfile()\n\ttmpFn2=tempfile()\n\ttmpFn3=tempfile()\n\ttmpFn4=tempfile()\t#fichero temporal para almacenar resultados de la regresion paso a paso\n\trasterStack(ndviFl,tmpFn1,interleave='BIP')\n\trasterStack(timeFl,tmpFn2,interleave='BIP')\n\trasterStack(aridFl,tmpFn3,interleave='BIP')\n\t\n\t#image info\n\tbands=length(ndviFl)\t\n\trows=GDALinfo(ndviFl[1])[1]\n\tcols=GDALinfo(ndviFl[1])[2]\n\t#browser()\n\t#calculo size del buffer de lectura para que lea bloques de 5000 elementos aproximadamente\n\titems=bands*rows*cols\n\t#este es un size optimo para la funcion 'by'\n\tpixelsToRead=trunc(5000/bands)\t\n\t#num de bloques de size itemsToRead\n\tnblocks=trunc(items/(pixelsToRead*bands))\n\t#tama?o del ultimo bloque\n\trest=rows*cols-nblocks*pixelsToRead\n\t\n\tif (!silent) pb=txtProgressBar(min=0,max=nblocks,char='*',width=20,style=3)\n\t\n\tdepf=file(tmpFn1,'rb')\n\tin1f=file(tmpFn2,'rb')\t\n\tin2f=file(tmpFn3,'rb')\n\toutf=file(tmpFn4,'w')\n\t\n#\tcat(sprintf('\\n%dx%dx%d, pixels=%d,   items=%d',rows,cols,bands,rows*cols,rows*cols*bands))#\n\t#cat(sprintf('\\n \t  pixToRead=%d, bloques=%d, resto=% dpixels',pixelsToRead,nblocks,rest))\n\t#cat('\\n')\n\t\n\t#por cada (bloque + 1) \n\tfor (i in 0:nblocks) {\n\t\tif (i == nblocks) {pixelsToRead=rest}\n\t\t#leer un linestoread de lineas del fichero de entrada\n\t\tY=readBin(depf,numeric(),pixelsToRead*bands,size=4)\n\t\tX1=readBin(in1f,numeric(),pixelsToRead*bands,size=4)\n\t\tX2=readBin(in2f,numeric(),pixelsToRead*bands,size=4)\n\t\n\t\tdf=cbind(Y,X1,X2,pixel=rep(1:pixelsToRead,each=bands))\n\t\trm(Y,X1,X2)\n\t\n\t\t#calcular regresion multiple\n\t\tcn=regStepDF(df)\n\t\t\n\t\t#escribir salida\n\t\twrite.table(round(cn,4),append=TRUE,sep='\\t',file=outf,col.names=FALSE,row.names=FALSE)\n\t\n\t\t#actualizo progressbar\n\t\tif (!silent) setTxtProgressBar(pb,i)\n\t}\n\t\n\tclose(depf)\n\tclose(in1f)\n\tclose(in2f)\n\tflush(outf)\n\tclose(outf)\n\t\n\tif (!silent) close(pb)\n\n\taux1=read.table(tmpFn4,header=FALSE,sep='\\t')\n\taux2=readGDAL(ndviFl[1],silent=TRUE)\n\tprint('writing output files')\n\tfor (i in 1:7) {\n\t\taux2$band1=aux1[,i]\n\t\twriteGDAL(aux2,outFl[i],...)\n\t}\t\n\tfile.remove(tmpFn1)\t\n\tfile.remove(tmpFn2)\t\n\tfile.remove(tmpFn3)\t\n\tfile.remove(tmpFn4)\t\n}\n\n###############################################\n# NAME: \n# PURPOSE:\n# INPUTS:\n# OUTPUTS:\n###############################################\nregStepDF=function (X){\n\tdimX=dim(X)[1]\n\tcols=max(X[,4])\n\tocases=length(unique(X[,4]))\n\t#quitar casos con algun NA en alguna de las bandas\n\taux=unique(X[is.na(X[,1]*X[,2]*X[,3]),4]) #lista de pixel con algun dato a NA\n\tX[X[,4] %in% aux,1]=NA\t\n\tX=na.omit(X) \n\n\tndimX=dim(X)[1]\n\tindex=unique(X[,4])\n\t#si todo el dataframe es iniutilizable\n\tif (ndimX==0) return(matrix(NA,ocases,7))\n\t\n\t#num de bandas en la matriz\n\tN=sum(X[,4]==X[,4][1])\n\tncases=length(index)\n\t\n\t\n\tRX=0\n\t#print(paste('dimX:',dimX,' dimXna:',ndimX,' ncases:',ncases))\n\t#browser()\n\t# Correlaciones simples entre variables segun Box 15.2\n\t#aux=(unlist(by(X[,1:3],X[,4],cor)))\n\tfor (i in 0:(ncases-1)){\t\t\n\t\tRX=rbind(RX,cor(X[(i*N+1):((i+1)*N),1:3])[c(6,2,3)])\n\t}\n\tRX=RX[-1,]\n\t\n\t#caso especial...\n\t#si en X hay un solo pixel valido, y el resto son NAs, \n\t#RX adopta la forma [ 0, 0, 0] \n\t#                   [ A, B, C]\n\t#y al quitar la primera linea pasa de ser una matriz a ser un vector...\n\t#as? que hay que forzar a ser matriz\n\tif (class(RX)=='numeric') {RX= as.matrix(t(RX))}\t\n\t\n\t#dim(aux)=c(9,ncases)\n\t#RX=t(aux[c(6,2,3),])\n\t#colnames(RX)=c('Rx1x2','Rx1Y','Rx2Y')\n\t\n\t# Coeficientes standard de regresion parcial\n\t# con ecuacion YP=BPY1*X1P+BPY2*X2P\n\t\n\tMBPY1=(RX[,2]-RX[,3]*RX[,1])/(1-RX[,1]^2)\n\tMBPY2=(RX[,3]-RX[,2]*RX[,1])/(1-RX[,1]^2)\n\t\n\t# Estadisticos de significacion de correlacion simple segun Box 15.4 con N<50\n\tDFS = N - 2\n\tMTS = RX * sqrt(DFS / (1 - RX^2))\n\t\n\t# Coeficiente de determinacion multiple\n\tMR2Y12 = RX[,2] * MBPY1 + RX[,3] * MBPY2\n\t\n\t# Estadistico de significacion de la regresion multiple con 2 variables independientes\n\tDFNUM = 2\n\tDFNUM2= 1\n\tDFDEN = N - 3\n\tMF = (MR2Y12 / 2) / ((1 - MR2Y12) / DFDEN)\n\t\n\t# Incremento en determinacion al meter la segunda variable\n\tARX=abs(RX)\n\tMRXY=ifelse(ARX[,2]>ARX[,3],RX[,2],RX[,3])\n\tMV2 =ifelse(ARX[,2]>ARX[,3],2,1)\n\tMF2 = (MR2Y12 - MRXY^2) / ((1 - MR2Y12) / DFDEN)\n\t\n\t# Distribuciones de Probabilidad\n\tMPrR2Y12 = 1-pf(MF,DFNUM,DFDEN)\n\tMPrR2Y12i= 1-pf(MF2,DFNUM2,DFDEN)\n\t\n\tMPr = 2*(1-pt(abs(MTS),DFS))\n\t\n\t#MPrX1X2 = 2*(1-pt(abs(MTS[,1]),DFS))\n\t#MPrX1Y  = 2*(1-pt(abs(MTS[,2]),DFS))\n\t#MPrX2Y  = 2*(1-pt(abs(MTS[,3]),DFS))\n\t\n\t#matriz de salida del efecto de la aridez y el tiempo q[,1] tiempo, q[,2] aridez, q[,3] respuesta de la vegetacion (1,2,3 o 4)\n\tq=matrix(-1,ncases,7) #casos sin NA\n\tnq=matrix(NA,cols-ncases,7) #casos con NA\n\tcolnames(q) =c('index','effect_time','effect_arid','veg_response','ta_single','tv_single','av_single')\n\tcolnames(nq)=c('index','effect_time','effect_arid','veg_response','ta_single','tv_single','av_single')\n\t\n\t#indetifica el pixel al que peretenece el resultado\n\tq[,1]=index\n\tnq[,1]=(1:cols)[-index]\n\t# wi almacena los indices de los casos donde se cumple la condicion...\n\t# 1a condicion \n\twi=which((MPrR2Y12<=0.1) & (MPrR2Y12i<=0.1))\n\tq[wi,2:3]=cbind(MBPY1[wi],MBPY2[wi])\n\t# 2a condicion \n\twi=c(which((MPrR2Y12<=0.1) & (MPrR2Y12i>0.1) & (MV2==2)),which((MPrR2Y12>0.1) & (MPr[,2]<=0.1)))\n\tq[wi,2:3]=cbind(RX[wi,2],0)\n\t# 3a condicion \n\twi=c(which((MPrR2Y12<=0.1) & (MPrR2Y12i>0.1) & (MV2==1)),which((MPrR2Y12>0.1) & (MPr[,2]>0.1) & (MPr[,3]<=0.1)))\n\tq[wi,2:3]=cbind(0,RX[wi,3])\n\t# 4a condicion \n\twi=which(((MPrR2Y12>0.1) & (MPr[,2]>0.1) & (MPr[,3]>0.1)))\n\tq[wi,2:3]=cbind(0,0)\n\t# calculo de la respuesta de la vegetacion (rv) en funcion del efecto del tiempo (et) y la aridez (ea)\n\t#  et  ea  rv\n\t# no 0  0-> 1\n\t# no 0 no 0 -> 3\n\t#  0 no 0 -> 2\n\t#  0  0-> 4\n\t\n\tq[,4]=ifelse(q[,2]!=0,ifelse(q[,3]==0,1,3),ifelse(q[,3]==0,4,2))\n\t\n\t# calculo de variables mostrando el efecto simple\n\tq[,5]=ifelse(MPr[,1]<=0.1,RX[,1],0)\n\tq[,6]=ifelse(MPr[,2]<=0.1,RX[,2],0)\n\tq[,7]=ifelse(MPr[,3]<=0.1,RX[,3],0)\n\t\n\tq=rbind(q,nq)\n\tq=q[order(q[,1]),]\n\t# ----------vector de resultados\n\treturn(q)\n\t\n\t# ----------devuelve vector completo para debug\n\t#round(c(R12, R1Y, R2Y, DFS, TS12, TS1Y, TS2Y, PrX1X2,PrX1Y,PrX2Y,BPY1, BPY2, BY1, BY2, A, R2Y12, DFNUM, DFDEN, F,PrR2Y12, V2, DFNUM2, F2,PrR2Y12i, DFM, TM1, TM2, TMP1, TMP2),6)\n}\n",
    "created" : 1427789729495.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "524|18|528|2|\n",
    "hash" : "980035165",
    "id" : "A9B50057",
    "lastKnownWriteTime" : 1427456103,
    "path" : "D:/trabajo/Alberto/r2dRue-lib/R/r2drue.r",
    "project_path" : "R/r2drue.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}